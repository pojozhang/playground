# 事务隔离级别

当多个事务并发执行时，由于不同的业务场景，存在不同的对数据一致性的需求。例如“一个查询语句必须查询到最新的数据，并且阻塞其他所有的写操作”。但由于需求的多样性，以及不同的场景存在不同的性能要求，因此数据库提供了多种事务隔离界别来满足不同的数据一致性的需求。

对于数据一致性的需求经常遇到以下几个问题：

- 脏读：指**一个事务读到其他事务未提交的数据**。
- 不可重复读：指**一个事务读取到其他事务修改过的数据**。
- 幻读：指**一个事务读取到其他事务最新插入的数据**。

各个隔离级别解决问题的对应关系：

|          |  读未提交 | 读已提交 | 可重复读  | 串行化 |
|----------|----------|--------|----------|-------|
| 脏读      | 未解决    |  解决  |   解决    |   解决 |
| 不可重复读 | 未解决    | 未解决  |   解决    |  解决 |
| 幻读      | 未解决    | 未解决  | 未完全解决 |  解决 |

## 可重复度读和幻读

比较特殊的一点是，在可重复读隔离级别下，并没有完全解决幻读的问题，具体是否存在幻读需要根据实际的使用场景判断。

一种情况是当交替使用`快照读`和`当前读`时，可能出现幻读。例如先通过`SELECT`语句进行查询，如果数据不存在则用`INSERT`语句进行插入，但此时由于其他并发事务已经插入了相同的数据，因此会得到索引冲突的异常，这时就发生了幻读。

> - 快照读： 读取数据的历史版本，不会对数据加锁。例如：`SELECT`操作。
> - 当前读： 读取数据的最新版本，会对数据加锁。例如：`INSERT`、`UPDATE`、`DELETE`、`SELECT FOR UPDATE`、`SELECT LOCK IN SHARE MODE`操作。

在可重复度读的隔离界别下，如果事务中只使用了当前读，由于会对数据上锁（对不存在的数据上间隙锁），因此可以认为是解决了幻读的问题。

## 参考

1. [《MySQL到底有没有解决幻读问题？》](https://heapdump.cn/article/4547714)
